/// Synthetic opcodes for bytecode optimization and fusion
/// 
/// Defines fused opcodes that combine common patterns for better performance:
/// - PUSH_ADD_INLINE: PUSH small_value + ADD operation combined
/// - PUSH_MUL_INLINE: PUSH small_value + MUL operation combined  
/// - PUSH_JUMP_INLINE: PUSH jump_target + JUMP operation combined
/// 
/// These synthetic opcodes are generated by the Planner during bytecode analysis
/// to reduce instruction stream length and improve cache utilization.
/// They maintain EVM semantics while providing performance optimizations.
const std = @import("std");
const Opcode = @import("opcode.zig").Opcode;

/// Synthetic opcodes for fused operations.
/// These values are chosen to avoid conflicts with standard EVM opcodes.
/// The compile-time check below ensures no conflicts exist.
pub const OpcodeSynthetic = enum(u8) {
    PUSH_ADD_INLINE = 0xB0,
    PUSH_ADD_POINTER = 0xB1,
    PUSH_MUL_INLINE = 0xB2,
    PUSH_MUL_POINTER = 0xB3,
    PUSH_DIV_INLINE = 0xB4,
    PUSH_DIV_POINTER = 0xB5,
    PUSH_JUMP_INLINE = 0xB6,
    PUSH_JUMP_POINTER = 0xB7,
    PUSH_JUMPI_INLINE = 0xB8,
    PUSH_JUMPI_POINTER = 0xB9,
    PUSH_SUB_INLINE = 0xBA,
    PUSH_SUB_POINTER = 0xBB,
    // New: PUSH+MLOAD and PUSH+MSTORE fusions (immediate offset)
    PUSH_MLOAD_INLINE = 0xBC,
    PUSH_MLOAD_POINTER = 0xBD,
    PUSH_MSTORE_INLINE = 0xBE,
    PUSH_MSTORE_POINTER = 0xBF,
};

// Compile-time check to ensure synthetic opcodes don't overlap with normal opcodes
comptime {
    @setEvalBranchQuota(10000);
    for (@typeInfo(OpcodeSynthetic).@"enum".fields) |syn_field| {
        // Try to convert the synthetic opcode value to a regular Opcode
        if (std.meta.intToEnum(Opcode, syn_field.value) catch null) |conflicting_opcode| {
            @compileError(std.fmt.comptimePrint(
                "Synthetic opcode {s} (0x{X}) conflicts with normal opcode {s}",
                .{ syn_field.name, syn_field.value, @tagName(conflicting_opcode) }
            ));
        } 
    }
}

test "OpcodeSynthetic values are unique and non-conflicting" {
    const opcodes = [_]u8{
        @intFromEnum(OpcodeSynthetic.PUSH_ADD_INLINE),
        @intFromEnum(OpcodeSynthetic.PUSH_ADD_POINTER),
        @intFromEnum(OpcodeSynthetic.PUSH_MUL_INLINE),
        @intFromEnum(OpcodeSynthetic.PUSH_MUL_POINTER),
        @intFromEnum(OpcodeSynthetic.PUSH_DIV_INLINE),
        @intFromEnum(OpcodeSynthetic.PUSH_DIV_POINTER),
        @intFromEnum(OpcodeSynthetic.PUSH_JUMP_INLINE),
        @intFromEnum(OpcodeSynthetic.PUSH_JUMP_POINTER),
        @intFromEnum(OpcodeSynthetic.PUSH_JUMPI_INLINE),
        @intFromEnum(OpcodeSynthetic.PUSH_JUMPI_POINTER),
        @intFromEnum(OpcodeSynthetic.PUSH_SUB_INLINE),
        @intFromEnum(OpcodeSynthetic.PUSH_SUB_POINTER),
    };
    for (opcodes, 0..) |op1, i| {
        for (opcodes[i+1..]) |op2| {
            try std.testing.expect(op1 != op2);
        }
    }
    try std.testing.expectEqual(@as(u8, 0xB0), @intFromEnum(OpcodeSynthetic.PUSH_ADD_INLINE));
    try std.testing.expectEqual(@as(u8, 0xB1), @intFromEnum(OpcodeSynthetic.PUSH_ADD_POINTER));
    try std.testing.expectEqual(@as(u8, 0xB2), @intFromEnum(OpcodeSynthetic.PUSH_MUL_INLINE));
    try std.testing.expectEqual(@as(u8, 0xB3), @intFromEnum(OpcodeSynthetic.PUSH_MUL_POINTER));
    try std.testing.expectEqual(@as(u8, 0xB4), @intFromEnum(OpcodeSynthetic.PUSH_DIV_INLINE));
    try std.testing.expectEqual(@as(u8, 0xB5), @intFromEnum(OpcodeSynthetic.PUSH_DIV_POINTER));
    try std.testing.expectEqual(@as(u8, 0xB6), @intFromEnum(OpcodeSynthetic.PUSH_JUMP_INLINE));
    try std.testing.expectEqual(@as(u8, 0xB7), @intFromEnum(OpcodeSynthetic.PUSH_JUMP_POINTER));
    try std.testing.expectEqual(@as(u8, 0xB8), @intFromEnum(OpcodeSynthetic.PUSH_JUMPI_INLINE));
    try std.testing.expectEqual(@as(u8, 0xB9), @intFromEnum(OpcodeSynthetic.PUSH_JUMPI_POINTER));
    try std.testing.expectEqual(@as(u8, 0xBA), @intFromEnum(OpcodeSynthetic.PUSH_SUB_INLINE));
    try std.testing.expectEqual(@as(u8, 0xBB), @intFromEnum(OpcodeSynthetic.PUSH_SUB_POINTER));
    try std.testing.expectEqual(@as(u8, 0xBC), @intFromEnum(OpcodeSynthetic.PUSH_MLOAD_INLINE));
    try std.testing.expectEqual(@as(u8, 0xBD), @intFromEnum(OpcodeSynthetic.PUSH_MLOAD_POINTER));
    try std.testing.expectEqual(@as(u8, 0xBE), @intFromEnum(OpcodeSynthetic.PUSH_MSTORE_INLINE));
    try std.testing.expectEqual(@as(u8, 0xBF), @intFromEnum(OpcodeSynthetic.PUSH_MSTORE_POINTER));
}
