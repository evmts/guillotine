# Plan Documentation

## Overview

The Plan is a runtime data structure that represents an optimized execution plan for EVM bytecode. Generated by the Planner during bytecode analysis, it contains an instruction stream of handler pointers with inline metadata, constants arrays, and PC-to-instruction mappings for efficient tail-call interpreter execution.

## Architecture & Design

### Core Design Principles

1. **Instruction Stream**: Linear array of handlers and metadata for optimal cache performance
2. **Platform Adaptation**: Different element sizes and storage strategies for 32-bit vs 64-bit platforms
3. **Metadata Inlining**: Small values embedded directly in instruction stream to reduce memory indirections
4. **Constants Separation**: Large values stored in separate array to minimize stream size
5. **Jump Resolution**: O(1) dynamic jump destination lookup

### Plan Structure

```zig
pub const Plan = struct {
    instructionStream: []InstructionElement,    // Handler pointers + inline metadata
    u256_constants: []WordType,                 // Large constants array  
    pc_to_instruction_idx: ?HashMap(PcType, InstructionIndexType), // Jump mapping
};
```

### Platform-Specific Elements

The Plan adapts to different platform architectures for optimal performance:

#### 64-bit Platforms (InstructionElement64)

```zig
pub const InstructionElement64 = packed union {
    handler: *const HandlerFn,                  // 8 bytes - function pointer
    jumpdest_metadata: JumpDestMetadata,        // 8 bytes - inline metadata
    inline_value: u64,                          // 8 bytes - inline constants
    pointer_index: u64,                         // 8 bytes - index into constants
};
```

**Benefits**:
- Larger inline values (up to 64-bit)
- JumpDestMetadata fits inline
- Better cache utilization with fewer indirections

#### 32-bit Platforms (InstructionElement32)

```zig
pub const InstructionElement32 = packed union {
    handler: *const HandlerFn,                  // 4 bytes - function pointer
    jumpdest_pointer: *const JumpDestMetadata,  // 4 bytes - pointer to metadata
    inline_value: u32,                          // 4 bytes - inline constants
    pointer_index: u32,                         // 4 bytes - index into constants
};
```

**Adaptations**:
- Smaller inline values (up to 32-bit)
- JumpDestMetadata stored via pointer
- Reduced memory usage per element

## API Reference

### Configuration

```zig
pub const PlanConfig = struct {
    WordType: type = u256,              // EVM word type
    maxBytecodeSize: u32 = 24_576,     // Max contract size (determines PcType)
    
    // Auto-derived types
    pub fn PcType(comptime self: @This()) type;  // u16 or u32 based on size
    pub fn validate(comptime self: @This()) void; // Compile-time validation
};
```

### Factory Function

```zig
pub fn Plan(comptime cfg: PlanConfig) type {
    // Returns specialized plan type with configuration
}
```

### Plan Instance Methods

#### Memory Management

```zig
// Initialize plan with instruction stream and constants
// (Typically done by Planner.create_instruction_stream)

// Free plan resources
pub fn deinit(self: *Self, allocator: std.mem.Allocator) void
```

#### Metadata Access

```zig
// Get metadata for opcodes that have associated data
pub fn getMetadata(
    self: *const Self,
    idx: *InstructionIndexType,
    comptime opcode: anytype,  // Opcode enum, OpcodeSynthetic, u8, or .enum_literal
) ReturnType  // Type determined by opcode

// Examples:
const push1_value = plan.getMetadata(&idx, .PUSH1);        // Returns u8
const push32_ptr = plan.getMetadata(&idx, .PUSH32);        // Returns *const u256
const jumpdest_meta = plan.getMetadata(&idx, .JUMPDEST);   // Returns JumpDestMetadata
const pc_value = plan.getMetadata(&idx, .PC);              // Returns PcType
```

#### Instruction Navigation

```zig
// Get next instruction handler and advance index appropriately
pub fn getNextInstruction(
    self: *const Self,
    idx: *InstructionIndexType,
    comptime opcode: anytype,
) *const HandlerFn

// Example usage in tail-call interpreter:
var idx: u32 = 0;
while (idx < plan.instructionStream.len) {
    const handler = plan.getNextInstruction(&idx, current_opcode);
    try handler(frame, plan);  // Tail call recursion
}
```

#### Jump Resolution

```zig
// Get instruction index for dynamic jumps
pub fn getInstructionIndexForPc(self: *const Self, pc: PcType) ?InstructionIndexType

// Used for dynamic JUMP/JUMPI operations
if (plan.getInstructionIndexForPc(target_pc)) |target_idx| {
    // Valid jump destination
    current_idx = target_idx;
} else {
    // Invalid jump - return error
    return error.InvalidJump;
}
```

#### Debugging Support

```zig
// Print plan structure for debugging
pub fn debugPrint(self: *const Self) void
```

## Metadata Types and Access

### JumpDestMetadata

```zig
pub const JumpDestMetadata = packed struct {
    gas: u32,           // Static gas cost for block
    min_stack: i16,     // Minimum stack height required
    max_stack: i16,     // Maximum stack height after execution
};
```

**Usage**: Stored inline on 64-bit platforms, via pointer on 32-bit platforms.

### Opcode-Specific Metadata

#### PUSH Operations

| Opcode | Return Type | Storage |
|--------|-------------|---------|
| PUSH1 | u8 | Always inline |
| PUSH2 | u16 | Always inline |
| PUSH3 | u24 | Always inline |  
| PUSH4 | u32 | Always inline |
| PUSH5-PUSH8 | u40-u64 | Inline on 64-bit, pointer on 32-bit |
| PUSH9-PUSH32 | *const WordType | Always pointer |

#### Synthetic Fusion Opcodes

| Opcode | Return Type | Description |
|--------|-------------|-------------|
| PUSH_ADD_INLINE | usize (64-bit) / u32 (32-bit) | Combined PUSH+ADD with inline value |
| PUSH_ADD_POINTER | *const WordType | Combined PUSH+ADD with pointer value |
| PUSH_MUL_INLINE | usize / u32 | Combined PUSH+MUL with inline value |
| PUSH_JUMP_INLINE | usize / u32 | Combined PUSH+JUMP with inline destination |

#### Special Operations

| Opcode | Return Type | Description |
|--------|-------------|-------------|
| JUMPDEST | JumpDestMetadata | Block analysis metadata |
| PC | PcType | Original program counter value |

## Performance Characteristics

### Instruction Stream Design

1. **Linear Access Pattern**: Sequential traversal optimizes CPU cache performance
2. **Minimal Indirections**: Small values inlined to reduce memory access
3. **Cache-Aligned Elements**: Elements sized to platform word size for optimal access
4. **Branch Prediction**: Consistent handler calling pattern improves prediction

### Platform Optimizations

#### 64-bit Platforms
- **Larger Inline Storage**: More values fit inline (up to 8 bytes)
- **Direct Metadata**: JumpDestMetadata stored inline without pointer indirection
- **Fewer Constants**: More values inlined means smaller constants array

#### 32-bit Platforms  
- **Compact Elements**: Smaller elements reduce memory usage
- **Pointer-Based Metadata**: JumpDestMetadata accessed via pointer
- **More Constants**: Smaller inline capacity means more values in constants array

### Memory Layout Optimization

```
Instruction Stream (hot data):
┌──────────────┬──────────────┬──────────────┬──────────────┐
│   Handler    │   Metadata   │   Handler    │   Metadata   │
│  (Function)  │  (Inline)    │  (Function)  │  (Pointer)   │
└──────────────┴──────────────┴──────────────┴──────────────┘

Constants Array (cold data):
┌──────────────┬──────────────┬──────────────┐
│  Large Val 1 │  Large Val 2 │  Large Val 3 │
│   (u256)     │   (u256)     │   (u256)     │
└──────────────┴──────────────┴──────────────┘
```

## Testing

### Test Coverage

The plan implementation includes comprehensive tests for:

1. **Metadata Access**: All opcode types return correct metadata types
2. **Platform Adaptation**: Both 32-bit and 64-bit element handling
3. **Instruction Navigation**: Proper index advancement for opcodes with/without metadata
4. **Jump Resolution**: PC-to-instruction mapping functionality
5. **Memory Management**: Proper allocation and deallocation of all resources
6. **Edge Cases**: Boundary conditions and error handling

### Test Execution

```bash
# Run all plan tests
zig build test

# Run plan-specific tests
zig build test -- --test-filter "Plan"
```

### Critical Test Scenarios

1. **Metadata Type Safety**: Compile-time verification that opcodes return correct types
2. **Platform Differences**: Inline vs pointer storage behaves correctly on both platforms
3. **Navigation Correctness**: Instruction advancement handles metadata presence accurately
4. **Resource Cleanup**: All allocated memory properly freed on deinit

## Context within EVM

### Integration with Planner

The Plan is created by the Planner's `create_instruction_stream` method:

```zig
// Planner analyzes bytecode and generates optimized plan
var planner = try Planner(.{}).init(allocator, cache_capacity);
const plan = try planner.getOrAnalyze(bytecode, handlers);

// Plan contains optimized instruction stream ready for execution
var idx: u32 = 0;
while (idx < plan.instructionStream.len) {
    const handler = plan.getNextInstruction(&idx, opcode);
    try handler(frame, plan);
}
```

### Integration with Frame/Interpreter

Plans are consumed by Frame-based interpreters for tail-call execution:

```zig
// Frame receives plan and executes via tail calls
pub fn execute(frame: *Frame, plan: *const Plan) !void {
    var idx: Plan.InstructionIndexType = 0;
    
    // Initial handler call starts tail call chain
    const first_handler = plan.getNextInstruction(&idx, first_opcode);
    try first_handler(frame, plan);
}
```

### Jump Handling

Dynamic jumps use the PC mapping for O(1) resolution:

```zig
// JUMP/JUMPI handler implementation
pub fn op_jump(frame: *anyopaque, plan_ptr: *const anyopaque) !noreturn {
    const plan: *const Plan = @ptrCast(@alignCast(plan_ptr));
    const target_pc = frame.stack.pop_unsafe();
    
    if (plan.getInstructionIndexForPc(@intCast(target_pc))) |target_idx| {
        // Valid jump - update instruction index and continue
        frame.instruction_idx = target_idx;
        const handler = plan.getNextInstruction(&frame.instruction_idx, next_opcode);
        return handler(frame, plan);
    } else {
        return error.InvalidJump;
    }
}
```

## Data-Oriented Design Benefits

### Cache Performance

1. **Hot/Cold Separation**: Instruction stream (hot) separate from constants (cold)
2. **Sequential Access**: Linear instruction stream maximizes cache hits
3. **Minimal Indirections**: Inline metadata reduces memory traversal

### Branch Prediction

1. **Consistent Patterns**: All handler calls follow same pattern
2. **Tail Call Optimization**: Compiler can optimize recursive handler calls
3. **Predictable Flow**: Linear progression through instruction stream

### Memory Efficiency

1. **Platform Adaptation**: Element size matches platform word size
2. **Smart Inlining**: Balance between stream size and indirection overhead
3. **Shared Constants**: Large values referenced by multiple instructions share storage

The Plan serves as the optimized runtime representation that enables high-performance EVM execution through intelligent bytecode transformation and platform-specific optimization strategies.