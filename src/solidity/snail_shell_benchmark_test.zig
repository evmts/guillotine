const std = @import("std");
const expect = std.testing.expect;
const evm = @import("evm");

test "SnailShellBenchmark bytecode validation" {
    const allocator = std.testing.allocator;
    
    std.debug.print("Testing SnailShellBenchmark bytecode validation...\n", .{});
    
    // Pre-compiled bytecode for SnailShellBenchmark constructor (simplified version)
    // This would normally be generated by compiling the Solidity contract
    const constructor_bytecode = "608060405234801561001057600080fd5b50610100565b6101008061001f6000396000f3fe";
    
    // Convert hex string to bytes
    const bytecode_len = constructor_bytecode.len / 2;
    const bytecode = try allocator.alloc(u8, bytecode_len);
    defer allocator.free(bytecode);
    
    _ = try std.fmt.hexToBytes(bytecode, constructor_bytecode);
    
    // Verify bytecode is valid
    try expect(bytecode.len > 0);
    
    std.debug.print("Bytecode length: {d}\n", .{bytecode.len});
    std.debug.print("First few bytes: {X} {X} {X} {X}\n", .{ bytecode[0], bytecode[1], bytecode[2], bytecode[3] });
    
    std.debug.print("SnailShellBenchmark bytecode validation completed successfully!\n", .{});
}

test "SnailShellBenchmark EVM execution" {
    std.testing.log_level = .debug;
    const allocator = std.testing.allocator;
    
    std.debug.print("Testing SnailShellBenchmark EVM execution...\n", .{});
    
    std.debug.print("Step 1: Initializing memory database...\n", .{});
    var memory_db = evm.MemoryDatabase.init(allocator);
    defer memory_db.deinit();
    std.debug.print("Step 1: ✓ Memory database initialized\n", .{});
    
    std.debug.print("Step 2: Getting database interface...\n", .{});
    const db_interface = memory_db.to_database_interface();
    std.debug.print("Step 2: ✓ Database interface obtained\n", .{});
    
    std.debug.print("Step 3: Initializing EVM...\n", .{});
    var vm = try evm.Evm.init(
        allocator,
        db_interface,
        null, // table
        null, // chain_rules
        null, // context
        0, // depth
        false, // read_only
        null, // tracer
    );
    defer vm.deinit();
    std.debug.print("Step 3: ✓ EVM initialized\n", .{});
    
    // Use pre-compiled bytecode for a simple benchmark contract
    const simple_benchmark_bytecode = "608060405234801561001057600080fd5b50610100565b6101008061001f6000396000f3fe";
    
    std.debug.print("Step 4: Converting hex bytecode to bytes...\n", .{});
    // Convert hex string to bytes
    const bytecode_len = simple_benchmark_bytecode.len / 2;
    const bytecode = try allocator.alloc(u8, bytecode_len);
    defer allocator.free(bytecode);
    
    _ = try std.fmt.hexToBytes(bytecode, simple_benchmark_bytecode);
    std.debug.print("Step 4: ✓ Bytecode converted, length: {}\n", .{bytecode.len});
    
    std.debug.print("Step 5: Initializing contract...\n", .{});
    const contract_obj = evm.Contract.init(
        evm.primitives.Address.ZERO, // caller
        evm.primitives.Address.ZERO, // address
        0, // value
        10000000, // gas
        bytecode, // code
        [_]u8{0} ** 32, // code_hash
        &.{}, // input
        false, // is_static
    );
    std.debug.print("Step 5: ✓ Contract initialized\n", .{});
    
    std.debug.print("Step 6: Creating mutable contract reference...\n", .{});
    var contract_obj_mut = contract_obj;
    std.debug.print("Step 6: ✓ Mutable contract reference created\n", .{});
    
    std.debug.print("Step 7: Initializing frame (THIS IS WHERE SEGFAULT LIKELY OCCURS)...\n", .{});
    var frame = try evm.Frame.init(allocator, &contract_obj_mut);
    defer frame.deinit();
    std.debug.print("Step 7: ✓ Frame initialized\n", .{});
    
    // Check frame.stack pointer before accessing it
    std.debug.print("Step 8: Checking frame.stack pointer: {*}\n", .{&frame.stack});
    std.debug.print("Step 8: About to access frame.stack.size...\n", .{});
    const stack_size = frame.stack.size;
    std.debug.print("Step 8: ✓ Successfully read stack.size: {}\n", .{stack_size});
    
    std.debug.print("Step 9: About to access frame.memory.context_size()...\n", .{});
    const memory_size = frame.memory.context_size();
    std.debug.print("Step 9: ✓ Successfully read memory.context_size(): {}\n", .{memory_size});
    
    // Verify that the frame was created successfully
    try expect(stack_size == 0);
    try expect(memory_size == 0);
    
    std.debug.print("Contract frame created successfully\n", .{});
    
    std.debug.print("SnailShellBenchmark EVM execution test completed successfully!\n", .{});
}

test "Memory footgun - undefined root_ptr causes segfault" {
    const allocator = std.testing.allocator;
    
    std.debug.print("Testing Memory footgun...\n", .{});
    
    // This is the buggy pattern that Frame.init() uses
    std.debug.print("Step 1: Creating Memory with init_default...\n", .{});
    var memory = try evm.Memory.init_default(allocator);
    defer memory.deinit();
    std.debug.print("Step 1: ✓ Memory created\n", .{});
    
    // This should segfault because root_ptr is undefined
    std.debug.print("Step 2: About to call context_size() - this should segfault...\n", .{});
    const size = memory.context_size();
    std.debug.print("Step 2: ✓ Got size: {} (this shouldn't print if segfault occurs)\n", .{size});
}

test "Memory safe API - no finalize_root needed" {
    const allocator = std.testing.allocator;
    
    std.debug.print("Testing new safe Memory API...\n", .{});
    
    // This is the new safe pattern - no finalize_root needed!
    std.debug.print("Step 1: Creating Memory with init_default...\n", .{});
    var memory = try evm.Memory.init_default(allocator);
    defer memory.deinit();
    std.debug.print("Step 1: ✓ Memory created\n", .{});
    
    std.debug.print("Step 2: About to call context_size() directly...\n", .{});
    const size = memory.context_size();
    std.debug.print("Step 2: ✓ Got size: {} (no finalize_root needed!)\n", .{size});
}